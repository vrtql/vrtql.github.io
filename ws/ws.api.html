<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 3. C API</title><link rel="stylesheet" type="text/css" href="screen.css"><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.2"><link rel="home" href="ws.html" title="VRTQL Websocket Client Library"><link rel="up" href="ws.html" title="VRTQL Websocket Client Library"><link rel="prev" href="ws.build.html" title="Chapter 2. Building and Installing"><link rel="next" href="ws.api.ws.html" title="2. Message API"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header" class="navtable"><tr><th colspan="3" align="center">Chapter 3. C API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ws.build.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ws.api.ws.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ws.api"></a>Chapter 3. C API</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="ws.api.html#ws.api.ws">1. The Client API</a></span></dt><dd><dl><dt><span class="section"><a href="ws.api.html#ws.api.ws.msg">1.1. Messages and Frames</a></span></dt><dt><span class="section"><a href="ws.api.html#ws.api.msg">1.2. The Message API</a></span></dt><dt><span class="section"><a href="ws.api.html#ws.api.ws.errors">1.3. Error Handling</a></span></dt><dt><span class="section"><a href="ws.api.html#ws.api.ws.tracing">1.4. Tracing</a></span></dt><dt><span class="section"><a href="ws.api.html#ws.api.ws.memory">1.5. Memory Management</a></span></dt></dl></dd><dt><span class="section"><a href="ws.api.ws.html">2. Message API</a></span></dt></dl></div><p>There are two APIs in the library: the WebSockts API and the Messaging
API. The WebSockets API is built solely upon WebSocket constructs: frames,
messages and connections, as you would expect. It intuitively follows the
concepts and structure laid out in the standard. The Messaging API is built on
top of the WebSockets API. While WebSockets provide a mechanism for real-time
bidirectional communication, it doesn't inherently offer things like you would
see in more heavyweight message protocols like AMQP. The Messaging API provides
a small step in that direction, but without the heft.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ws.api.ws"></a>1. The Client API</h2></div></div></div><p>There are three objects in the C API: connections given by the
<code class="classname"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_cnx">vws_cnx</a></code>, <code class="classname"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_frame">vws_frame</a></code> and <code class="classname"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_msg">vws_msg</a></code>. While frames are a concrete object in
the standard, messages are not. Messages are expressed in terms of frames. A
message is one or more frames, terminated by a frame with the
<code class="literal">FIN</code> bit set. So a message can be a single frame, which would
have its <code class="literal">FIN</code> bit set. Or a message can be multiple frames the
last of which has the <code class="literal">FIN</code> bet set. In the latter case, the
first frame contains the frame type (<code class="literal">TEXT</code> or
<code class="literal">BINARY</code>). Subsequent frames in the chain consist of
continuation (<code class="literal">CONTINUATION</code>) frames (another frame type). The
last of these continuation frames will have the <code class="literal">FIN</code> bit set,
signifying the end of the message.</p><p>The following example illustrates the basic usage of the Client API:

</p><pre class="programlisting">
<span class="preprocessor">#include</span> <span class="string">&lt;vrtql/websocket.h&gt;</span>

<span class="type">int</span> <span class="function-name">main</span>()
{
    <span class="comment-delimiter">// </span><span class="comment">Create connection object
</span>    <span class="type">vws_cnx</span>* <span class="variable-name">cnx</span> = vws_cnx_new();

    <span class="comment-delimiter">// </span><span class="comment">Set connection timeout to 2 seconds (the default is 10). This applies
</span>    <span class="comment-delimiter">// </span><span class="comment">both to connect() and to read operations (i.e. poll()).
</span>    vws_socket_set_timeout((<span class="type">vws_socket</span>*)cnx, 2);

    <span class="comment-delimiter">// </span><span class="comment">Connect. This will automatically use SSL if "wss" scheme is used.
</span>    <span class="type">cstr</span> <span class="variable-name">uri</span> = <span class="string">"ws://localhost:8181/websocket"</span>;
    <span class="keyword">if</span> (vws_connect(cnx, uri) == <span class="constant">false</span>)
    {
        printf(<span class="string">"Failed to connect to the WebSocket server\n"</span>);
        vws_cnx_free(cnx);
        <span class="keyword">return</span> 1;
    }

    <span class="comment-delimiter">// </span><span class="comment">Can check connection state this way. Should always be true here as we
</span>    <span class="comment-delimiter">// </span><span class="comment">just successfully connected.
</span>    assert(vws_socket_is_connected((<span class="type">vws_socket</span>*)cnx) == <span class="constant">true</span>);

    <span class="comment-delimiter">// </span><span class="comment">Enable tracing. This will dump frames to the console in human-readable
</span>    <span class="comment-delimiter">// </span><span class="comment">format as they are sent and received.
</span>    vrtql.trace = VT_PROTOCOL;

    <span class="comment-delimiter">// </span><span class="comment">Send a TEXT frame
</span>    vws_frame_send_text(cnx, <span class="string">"Hello, world!"</span>);

    <span class="comment-delimiter">// </span><span class="comment">Receive websocket message
</span>    <span class="type">vws_msg</span>* <span class="variable-name">reply</span> = vws_msg_recv(cnx);

    <span class="keyword">if</span> (reply == <span class="constant">NULL</span>)
    {
        <span class="comment-delimiter">// </span><span class="comment">There was no message received and it resulted in timeout
</span>    }
    <span class="keyword">else</span>
    {
        <span class="comment-delimiter">// </span><span class="comment">Free message
</span>        vws_msg_free(reply);
    }

    <span class="comment-delimiter">// </span><span class="comment">Send a BINARY message
</span>    vws_msg_send_binary(cnx, <span class="string">"Hello, world!"</span>, 14);

    <span class="comment-delimiter">// </span><span class="comment">Receive websocket message
</span>    reply = vws_msg_recv(cnx);

    <span class="keyword">if</span> (reply == <span class="constant">NULL</span>)
    {
        <span class="comment-delimiter">// </span><span class="comment">There was no message received and it resulted in timeout
</span>    }
    <span class="keyword">else</span>
    {
        <span class="comment-delimiter">// </span><span class="comment">Free message
</span>        vws_msg_free(reply);
    }

    vws_disconnect(cnx);

    <span class="keyword">return</span> 0;
}
</pre><p>

</p><p>In summary, what you see here is a synchrounos (blocking) client
connection model with an optional timeout. This keeps the API simple and
intuitive. Typically from the client-side this is what you want. The underlying
socket read (<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/socket.c.html#vws_socket_read">vws_socket_read</a>()</code>) and
write (<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/socket.c.html#vws_socket_write">vws_socket_write</a>()</code>) operations
are implemented using the operating systems’s <code class="function">poll()</code>
facility, which provides the combination of blocking and timeout. As such, you
can send messages/frames and easily wait for responses to arrive with the option
of a timeout for error detection.</p><p>Concurrency in this model would be employed with threads rather than
non-blocking I/O. Multiple connections can operate independently within the
threads they are created in. The only limitation is that a connection should
only be used within the thread it was created in, as it relies on a thread-local
variable (<code class="varname">vrtql</code>) for error handling and tracing.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ws.api.ws.msg"></a>1.1. Messages and Frames</h3></div></div></div><p>The <code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_msg_send_text">vws_msg_send_text</a>()</code>,
<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_msg_send_binary">vws_msg_send_binary</a>()</code>,
<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_msg_send_data">vws_msg_send_data</a>()</code> and
<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_msg_recv">vws_msg_recv</a>()</code> deal in messages
but work in terms of frames. The send functions send messages out as a single
frame. The receive function collects incoming frames until it gets one with the
FIN bit set. Then it concatenates the data from all frames in the sequence,
forming a single message which it provides as the return value.</p><p>If you need more fine-grained control, you can deal directly in frames if
you need to. There are equivalent functions to send and receive frames:
<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_frame_send_text">vws_frame_send_text</a>()</code>, <code class="function">
<a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_frame_send_binary">vws_frame_send_binary</a>()</code>, <code class="function"> <a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_frame_send_data">vws_frame_send_data</a>()</code> and <code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_frame_recv">vws_frame_recv</a>()</code>. As frames arrive they are put
on a receive queue. The <code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_frame_recv">vws_frame_recv</a>()</code> function checks this queue and
returns the first one it finds. If the queue is empty then it intiates a socket
read and waits until the a frame arrives. If no frame arrives within the given
timeout, it will return <code class="literal">NULL</code>. The <code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_msg_recv">vws_msg_recv</a>()</code> function works by the exact same
logic but with messages.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ws.api.msg"></a>1.2. The Message API</h3></div></div></div><p>The client API includes an optional Message API which provides additional
features for the purposes of creating protocols similar to what you would see in
AMQP and MQTT, providing something that sits in between the two. This consists
of a specific message structure (<code class="classname"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/message.h.html#vrtql_msg">vrtql_msg</a></code>) and functions to send (<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/message.h.html#vrtql_msg_send">vrtql_msg_send</a>()</code>) and receive (<code class="function"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/message.h.html#vrtql_msg_recv">vrtql_msg_recv</a>()</code>) it. The message structure
includes two maps (hashtables of string key/value pairs) and a payload. One map,
called <code class="varname">routing</code>, is designed to hold routing information for
messaging applications. The other map, called <code class="varname">headers</code>, is for
application use. The payload can hold both text and binary data.</p><p>The Message API works atop the native WebSocket API. It takes a normal
WebSocket connection (<code class="classname"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/websocket.h.html#vws_cnx">vws_cnx</a></code>)
and uses it to send and receive messages in the same way as the WebSocket
API. The only difference is that it deals in <code class="classname"><a xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:d="http://docbook.org/ns/docbook" href="https://vrtql.github.io/ws-code-doc/root/codebrowser/src/message.h.html#vrtql_msg">vrtql_msg</a></code> objects and automatically handles
serialization and deserialization on and off the wire. Messages can be
serialized in two formats: JSON and MessagePack. Both formats can be sent over
the same connection on a message-by-message basis. That is, the connection is
able to auto-detect each incoming message's format and deserialize
accordingly. Thus connections support mixed-content messages: JSON and
MessagePack.</p><p>The following is a basic example of using the high-level messaging API.

</p><pre class="programlisting">
<span class="preprocessor">#include</span> <span class="string">&lt;vrtql/message.h&gt;</span>

<span class="type">int</span> <span class="function-name">main</span>()
{
    <span class="comment-delimiter">// </span><span class="comment">Create connection object
</span>    <span class="type">vws_cnx</span>* <span class="variable-name">cnx</span> = vws_cnx_new();

    <span class="comment-delimiter">// </span><span class="comment">Connect. This will automatically use SSL if "wss" scheme is used.
</span>    <span class="type">cstr</span> <span class="variable-name">uri</span> = <span class="string">"ws://localhost:8181/websocket"</span>;
    <span class="keyword">if</span> (vws_connect(cnx, uri) == <span class="constant">false</span>)
    {
        printf(<span class="string">"Failed to connect to the WebSocket server\n"</span>);
        vws_cnx_free(cnx);
        <span class="keyword">return</span> 1;
    }

    <span class="comment-delimiter">// </span><span class="comment">Enable tracing. This will dump frames to the console in human-readable
</span>    <span class="comment-delimiter">// </span><span class="comment">format as they are sent and received.
</span>    vrtql.trace = VT_PROTOCOL;

  <span class="comment-delimiter">// </span><span class="comment">Create
</span>    <span class="type">vrtql_msg</span>* <span class="variable-name">request</span> = vrtql_msg_new();

    vrtql_msg_set_routing(request, <span class="string">"key"</span>, <span class="string">"value"</span>);
    vrtql_msg_set_header(request, <span class="string">"key"</span>, <span class="string">"value"</span>);
    vrtql_msg_set_content(request, <span class="string">"payload"</span>);

    <span class="comment-delimiter">// </span><span class="comment">Send
</span>    <span class="keyword">if</span> (vrtql_msg_send(cnx, request) &lt; 0)
    {
        printf(<span class="string">"Failed to send: %s\n"</span>, vrtql.e.text);
        vrtql_msg_free(request);
        vws_cnx_free(cnx);
        <span class="keyword">return</span> 1;
    }

    <span class="comment-delimiter">// </span><span class="comment">Receive
</span>    <span class="type">vrtql_msg</span>* <span class="variable-name">reply</span> = vrtql_msg_recv(cnx);

    <span class="keyword">if</span> (reply == <span class="constant">NULL</span>)
    {
        <span class="comment-delimiter">// </span><span class="comment">There was no message received and it resulted in timeout
</span>    }
    <span class="keyword">else</span>
    {
        <span class="comment-delimiter">// </span><span class="comment">Free message
</span>        vrtql_msg_free(reply);
    }

    <span class="comment-delimiter">// </span><span class="comment">Cleanup
</span>    vrtql_msg_free(request);

    vws_disconnect(cnx);

    <span class="keyword">return</span> 0;
}
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ws.api.ws.errors"></a>1.3. Error Handling</h3></div></div></div><p>

</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ws.api.ws.tracing"></a>1.4. Tracing</h3></div></div></div><p>

</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ws.api.ws.memory"></a>1.5. Memory Management</h3></div></div></div><p>

</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer" class="navtable"><tr><td width="40%" align="left"><a accesskey="p" href="ws.build.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ws.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ws.api.ws.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 2. Building and Installing </td><td width="20%" align="center"><a accesskey="h" href="ws.html">Home</a></td><td width="40%" align="right" valign="top"> 2. Message API</td></tr></table></div></body></html>
